"""Main module for the MCP server application."""

from __future__ import annotations

import os
import threading

import uvicorn
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from mcp.server.fastmcp import FastMCP  # pylint: disable=import-error
from prometheus_client import Counter

from gitingest.entrypoint import ingest_async
from gitingest.utils.logging_config import get_logger
from server.metrics_server import start_metrics_server

# Initialize logger for this module
logger = get_logger(__name__)

# Create Prometheus metrics
fastmcp_ingest_counter = Counter("gitingest_fastmcp_ingest_total", "Number of FastMCP ingests", ["status"])
fastmcp_tool_calls_counter = Counter(
    "gitingest_fastmcp_tool_calls_total",
    "Number of FastMCP tool calls",
    ["tool_name", "status"],
)

# Create the FastMCP server instance
mcp = FastMCP("gitingest")


@mcp.tool()
async def ingest_repository(
    source: str,
    max_file_size: int = 10485760,
    include_patterns: list[str] | None = None,
    exclude_patterns: list[str] | None = None,
    branch: str | None = None,
    *,
    include_gitignored: bool = False,
    include_submodules: bool = False,
    token: str | None = None,
) -> str:
    """Ingest a Git repository or local directory and return a structured digest for LLMs.

    Args:
        source: Git repository URL or local directory path
        max_file_size: Maximum file size to process in bytes (default: 10MB)
        include_patterns: Shell-style patterns to include files
        exclude_patterns: Shell-style patterns to exclude files
        branch: Git branch to clone and ingest
        include_gitignored: Include files matched by .gitignore
        include_submodules: Include repository's submodules
        token: GitHub personal access token for private repositories

    """
    try:
        fastmcp_tool_calls_counter.labels(tool_name="ingest_repository", status="started").inc()
        logger.info("Starting MCP ingestion", extra={"source": source})

        # Convert patterns to sets if provided
        include_patterns_set = set(include_patterns) if include_patterns else None
        exclude_patterns_set = set(exclude_patterns) if exclude_patterns else None

        # Call the ingestion function
        summary, tree, content = await ingest_async(
            source=source,
            max_file_size=max_file_size,
            include_patterns=include_patterns_set,
            exclude_patterns=exclude_patterns_set,
            branch=branch,
            include_gitignored=include_gitignored,
            include_submodules=include_submodules,
            token=token,
            output=None,  # Don't write to file, return content instead
        )

        fastmcp_ingest_counter.labels(status="success").inc()
        fastmcp_tool_calls_counter.labels(tool_name="ingest_repository", status="success").inc()

    except Exception:
        logger.exception("Error during ingestion")
        fastmcp_ingest_counter.labels(status="error").inc()
        fastmcp_tool_calls_counter.labels(tool_name="ingest_repository", status="error").inc()
        return "Error ingesting repository: An internal error occurred"

    # Create a structured response and return directly
    return f"""# Repository Analysis: {source}

## Summary
{summary}

## File Structure
```
{tree}
```

## Content
{content}

---
*Generated by Gitingest MCP Server*
"""


async def start_mcp_server_tcp(host: str = "127.0.0.1", port: int = 8001) -> None:
    """Start the MCP server with HTTP transport using SSE."""
    logger.info("Starting Gitingest MCP server with HTTP/SSE transport on %s:%s", host, port)

    # Start metrics server in a separate thread if enabled
    if os.getenv("GITINGEST_METRICS_ENABLED") is not None:
        metrics_host = os.getenv("GITINGEST_METRICS_HOST", "127.0.0.1")
        metrics_port = int(os.getenv("GITINGEST_METRICS_PORT", "9090"))
        metrics_thread = threading.Thread(
            target=start_metrics_server,
            args=(metrics_host, metrics_port),
            daemon=True,
        )
        metrics_thread.start()
        logger.info("Started metrics server on %s:%s", metrics_host, metrics_port)

    tcp_app = FastAPI(title="Gitingest MCP Server", description="MCP server over HTTP/SSE")

    # Add CORS middleware for remote access
    tcp_app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],  # In production, specify allowed origins
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    @tcp_app.get("/health")
    async def health_check() -> dict[str, str]:
        """Health check endpoint."""
        return {"status": "healthy", "transport": "http", "version": "1.0"}

    @tcp_app.post("/message")
    async def handle_message(message: dict) -> JSONResponse:  # pylint: disable=too-many-return-statements
        """Handle MCP messages via HTTP POST."""
        try:
            logger.info("Received MCP message: %s", message)

            # Handle different MCP message types
            if message.get("method") == "initialize":
                return JSONResponse(
                    {
                        "jsonrpc": "2.0",
                        "id": message.get("id"),
                        "result": {
                            "protocolVersion": "2024-11-05",
                            "capabilities": {
                                "tools": {},
                            },
                            "serverInfo": {
                                "name": "gitingest",
                                "version": "1.0.0",
                            },
                        },
                    },
                )

            if message.get("method") == "tools/list":
                return JSONResponse(
                    {
                        "jsonrpc": "2.0",
                        "id": message.get("id"),
                        "result": {
                            "tools": [
                                {
                                    "name": "ingest_repository",
                                    "description": (
                                        "Ingest a Git repository or local directory "
                                        "and return a structured digest for LLMs"
                                    ),
                                    "inputSchema": {
                                        "type": "object",
                                        "properties": {
                                            "source": {
                                                "type": "string",
                                                "description": "Git repository URL or local directory path",
                                            },
                                            "max_file_size": {
                                                "type": "integer",
                                                "description": "Maximum file size to process in bytes",
                                                "default": 10485760,
                                            },
                                        },
                                        "required": ["source"],
                                    },
                                },
                            ],
                        },
                    },
                )

            if message.get("method") == "tools/call":
                tool_name = message.get("params", {}).get("name")
                arguments = message.get("params", {}).get("arguments", {})

                if tool_name == "ingest_repository":
                    try:
                        result = await ingest_repository(**arguments)
                        return JSONResponse(
                            {
                                "jsonrpc": "2.0",
                                "id": message.get("id"),
                                "result": {
                                    "content": [{"type": "text", "text": result}],
                                },
                            },
                        )
                    except Exception:
                        logger.exception("Tool execution failed")
                        return JSONResponse(
                            {
                                "jsonrpc": "2.0",
                                "id": message.get("id"),
                                "error": {
                                    "code": -32603,
                                    "message": "Tool execution failed",
                                },
                            },
                        )

                else:
                    return JSONResponse(
                        {
                            "jsonrpc": "2.0",
                            "id": message.get("id"),
                            "error": {
                                "code": -32601,
                                "message": f"Unknown tool: {tool_name}",
                            },
                        },
                    )

            else:
                return JSONResponse(
                    {
                        "jsonrpc": "2.0",
                        "id": message.get("id"),
                        "error": {
                            "code": -32601,
                            "message": f"Unknown method: {message.get('method')}",
                        },
                    },
                )

        except Exception:
            logger.exception("Error handling MCP message")
            return JSONResponse(
                {
                    "jsonrpc": "2.0",
                    "id": message.get("id") if "message" in locals() else None,
                    "error": {
                        "code": -32603,
                        "message": "Internal server error",
                    },
                },
            )

    # Start the HTTP server
    config = uvicorn.Config(
        tcp_app,
        host=host,
        port=port,
        log_config=None,  # Use our logging config
        access_log=False,
    )
    server = uvicorn.Server(config)
    await server.serve()
