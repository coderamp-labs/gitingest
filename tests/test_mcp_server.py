"""Tests for the MCP server functionality."""

from __future__ import annotations

import asyncio
from unittest.mock import AsyncMock, MagicMock, patch

import pytest
from mcp.types import TextContent, Tool

# Import the module functions and server instance
from gitingest.mcp_server import (
    _handle_ingest_repository,
    _run_stdio,
    app,
    call_tool,
    list_tools,
    start_mcp_server,
)


class TestMCPListTools:
    """Test cases for the list_tools handler."""

    @pytest.mark.asyncio
    async def test_list_tools_returns_correct_tools(self):
        """Test that list_tools returns the expected tools."""
        tools = await list_tools()

        assert isinstance(tools, list)
        assert len(tools) == 1

        tool = tools[0]
        assert isinstance(tool, Tool)
        assert tool.name == "ingest_repository"
        assert "ingest a git repository" in tool.description.lower()

    @pytest.mark.asyncio
    async def test_list_tools_schema_validation(self):
        """Test that the ingest_repository tool has correct schema."""
        tools = await list_tools()
        ingest_tool = tools[0]

        # Check required schema structure
        schema = ingest_tool.inputSchema
        assert schema["type"] == "object"
        assert "properties" in schema
        assert "required" in schema

        # Check required fields
        assert "source" in schema["required"]

        # Check properties
        properties = schema["properties"]
        assert "source" in properties
        assert properties["source"]["type"] == "string"

        # Check optional parameters
        optional_params = [
            "max_file_size",
            "include_patterns",
            "exclude_patterns",
            "branch",
            "include_gitignored",
            "include_submodules",
            "token",
        ]
        for param in optional_params:
            assert param in properties

    @pytest.mark.asyncio
    async def test_list_tools_source_examples(self):
        """Test that the source parameter has proper examples."""
        tools = await list_tools()
        source_prop = tools[0].inputSchema["properties"]["source"]

        assert "examples" in source_prop
        examples = source_prop["examples"]
        assert len(examples) >= 3
        assert any("github.com" in ex for ex in examples)
        assert any("/path/to/" in ex for ex in examples)
        assert "." in examples


class TestMCPCallTool:
    """Test cases for the call_tool handler."""

    @pytest.mark.asyncio
    async def test_call_tool_ingest_repository_success(self):
        """Test successful repository ingestion through call_tool."""
        with patch("gitingest.mcp_server.ingest_async") as mock_ingest:
            mock_ingest.return_value = (
                "Repository summary",
                "File tree structure",
                "Repository content",
            )

            result = await call_tool("ingest_repository", {"source": "https://github.com/test/repo"})

            assert isinstance(result, list)
            assert len(result) == 1
            assert isinstance(result[0], TextContent)
            assert result[0].type == "text"

            content = result[0].text
            assert "Repository Analysis" in content
            assert "Repository summary" in content
            assert "File tree structure" in content
            assert "Repository content" in content
            assert "Generated by Gitingest MCP Server" in content

    @pytest.mark.asyncio
    async def test_call_tool_unknown_tool(self):
        """Test handling of unknown tool calls."""
        result = await call_tool("unknown_tool", {})

        assert isinstance(result, list)
        assert len(result) == 1
        assert isinstance(result[0], TextContent)
        assert "Unknown tool: unknown_tool" in result[0].text

    @pytest.mark.asyncio
    async def test_call_tool_exception_handling(self):
        """Test exception handling in call_tool."""
        with patch("gitingest.mcp_server._handle_ingest_repository") as mock_handle:
            mock_handle.side_effect = Exception("Test exception")

            result = await call_tool("ingest_repository", {"source": "test"})

            assert isinstance(result, list)
            assert len(result) == 1
            assert "Error executing ingest_repository: Test exception" in result[0].text

    @pytest.mark.asyncio
    async def test_call_tool_logs_errors(self):
        """Test that call_tool logs errors properly."""
        with (
            patch("gitingest.mcp_server._handle_ingest_repository") as mock_handle,
            patch("gitingest.mcp_server.logger") as mock_logger,
        ):
            test_exception = Exception("Test exception")
            mock_handle.side_effect = test_exception

            await call_tool("ingest_repository", {"source": "test"})

            mock_logger.error.assert_called_once()
            args, kwargs = mock_logger.error.call_args
            assert "Error in tool call ingest_repository: Test exception" in args[0]
            assert kwargs.get("exc_info") is True


class TestHandleIngestRepository:
    """Test cases for the _handle_ingest_repository helper function."""

    @pytest.mark.asyncio
    async def test_handle_ingest_repository_minimal_args(self):
        """Test repository ingestion with minimal arguments."""
        with patch("gitingest.mcp_server.ingest_async") as mock_ingest:
            mock_ingest.return_value = ("summary", "tree", "content")

            result = await _handle_ingest_repository({"source": "https://github.com/test/repo"})

            assert isinstance(result, list)
            assert len(result) == 1
            assert isinstance(result[0], TextContent)

            # Verify ingest_async was called with correct defaults
            mock_ingest.assert_called_once_with(
                source="https://github.com/test/repo",
                max_file_size=10485760,
                include_patterns=None,
                exclude_patterns=None,
                branch=None,
                include_gitignored=False,
                include_submodules=False,
                token=None,
                output=None,
            )

    @pytest.mark.asyncio
    async def test_handle_ingest_repository_all_args(self):
        """Test repository ingestion with all arguments."""
        with patch("gitingest.mcp_server.ingest_async") as mock_ingest:
            mock_ingest.return_value = ("summary", "tree", "content")

            args = {
                "source": "https://github.com/test/repo",
                "max_file_size": 1048576,
                "include_patterns": ["*.py", "*.js"],
                "exclude_patterns": ["tests/*", "build/*"],
                "branch": "develop",
                "include_gitignored": True,
                "include_submodules": True,
                "token": "ghp_test_token",
            }

            result = await _handle_ingest_repository(args)

            assert isinstance(result, list)
            assert len(result) == 1

            # Verify ingest_async was called with all parameters
            mock_ingest.assert_called_once_with(
                source="https://github.com/test/repo",
                max_file_size=1048576,
                include_patterns={"*.py", "*.js"},
                exclude_patterns={"tests/*", "build/*"},
                branch="develop",
                include_gitignored=True,
                include_submodules=True,
                token="ghp_test_token",
                output=None,
            )

    @pytest.mark.asyncio
    async def test_handle_ingest_repository_pattern_conversion(self):
        """Test that patterns are correctly converted to sets."""
        with patch("gitingest.mcp_server.ingest_async") as mock_ingest:
            mock_ingest.return_value = ("summary", "tree", "content")

            args = {
                "source": "test",
                "include_patterns": ["*.py"],
                "exclude_patterns": ["*.txt"],
            }

            await _handle_ingest_repository(args)

            call_args = mock_ingest.call_args[1]
            assert isinstance(call_args["include_patterns"], set)
            assert isinstance(call_args["exclude_patterns"], set)
            assert call_args["include_patterns"] == {"*.py"}
            assert call_args["exclude_patterns"] == {"*.txt"}

    @pytest.mark.asyncio
    async def test_handle_ingest_repository_none_patterns(self):
        """Test handling of None patterns."""
        with patch("gitingest.mcp_server.ingest_async") as mock_ingest:
            mock_ingest.return_value = ("summary", "tree", "content")

            args = {
                "source": "test",
                "include_patterns": None,
                "exclude_patterns": None,
            }

            await _handle_ingest_repository(args)

            call_args = mock_ingest.call_args[1]
            assert call_args["include_patterns"] is None
            assert call_args["exclude_patterns"] is None

    @pytest.mark.asyncio
    async def test_handle_ingest_repository_exception(self):
        """Test exception handling in _handle_ingest_repository."""
        with (
            patch("gitingest.mcp_server.ingest_async") as mock_ingest,
            patch("gitingest.mcp_server.logger") as mock_logger,
        ):
            test_exception = Exception("Ingestion failed")
            mock_ingest.side_effect = test_exception

            result = await _handle_ingest_repository({"source": "test"})

            assert isinstance(result, list)
            assert len(result) == 1
            assert "Error ingesting repository: Ingestion failed" in result[0].text

            # Verify error was logged
            mock_logger.error.assert_called_once()
            args, kwargs = mock_logger.error.call_args
            assert "Error during ingestion: Ingestion failed" in args[0]
            assert kwargs.get("exc_info") is True

    @pytest.mark.asyncio
    async def test_handle_ingest_repository_logs_info(self):
        """Test that _handle_ingest_repository logs info messages."""
        with (
            patch("gitingest.mcp_server.ingest_async") as mock_ingest,
            patch("gitingest.mcp_server.logger") as mock_logger,
        ):
            mock_ingest.return_value = ("test summary", "tree", "content")

            await _handle_ingest_repository({"source": "https://github.com/test/repo"})

            # Check that info message was logged for start
            assert mock_logger.info.call_count == 1
            mock_logger.info.assert_called_with(
                "Starting MCP ingestion", extra={"source": "https://github.com/test/repo"}
            )

    @pytest.mark.asyncio
    async def test_handle_ingest_repository_response_format(self):
        """Test the format of the response content."""
        with patch("gitingest.mcp_server.ingest_async") as mock_ingest:
            mock_ingest.return_value = (
                "Test repository with 5 files",
                "src/\n  main.py\n  utils.py",
                "File contents here...",
            )

            result = await _handle_ingest_repository({"source": "https://github.com/test/repo"})

            content = result[0].text

            # Check response structure
            assert content.startswith("# Repository Analysis: https://github.com/test/repo")
            assert "## Summary" in content
            assert "Test repository with 5 files" in content
            assert "## File Structure" in content
            assert "```\nsrc/\n  main.py\n  utils.py\n```" in content
            assert "## Content" in content
            assert "File contents here..." in content
            assert content.strip().endswith("*Generated by Gitingest MCP Server*")


class TestMCPServerIntegration:
    """Integration tests for the MCP server."""

    @pytest.mark.asyncio
    async def test_server_instance_created(self):
        """Test that the MCP server instance is properly created."""
        assert app is not None
        assert app.name == "gitingest"

    @pytest.mark.asyncio
    async def test_start_mcp_server_calls_stdio(self):
        """Test that start_mcp_server calls the stdio runner."""
        with patch("gitingest.mcp_server._run_stdio") as mock_run_stdio:
            mock_run_stdio.return_value = AsyncMock()

            await start_mcp_server()

            mock_run_stdio.assert_called_once()

    @pytest.mark.asyncio
    async def test_start_mcp_server_logs_startup(self):
        """Test that start_mcp_server logs startup message."""
        with (
            patch("gitingest.mcp_server._run_stdio") as mock_run_stdio,
            patch("gitingest.mcp_server.logger") as mock_logger,
        ):
            mock_run_stdio.return_value = AsyncMock()

            await start_mcp_server()

            mock_logger.info.assert_called_once_with(
                "Starting Gitingest MCP server with stdio transport",
            )

    @pytest.mark.asyncio
    async def test_run_stdio_integration(self):
        """Test _run_stdio function integration."""
        with patch("gitingest.mcp_server.stdio_server") as mock_stdio_server:
            # Mock the async context manager
            mock_streams = (MagicMock(), MagicMock())
            mock_context = AsyncMock()
            mock_context.__aenter__.return_value = mock_streams
            mock_context.__aexit__.return_value = None
            mock_stdio_server.return_value = mock_context

            # Mock app.run to avoid actually running the server
            with (
                patch.object(app, "run") as mock_run,
                patch.object(app, "create_initialization_options") as mock_init_options,
            ):
                mock_init_options.return_value = {}
                mock_run.return_value = AsyncMock()

                await _run_stdio()

                # Verify stdio_server was called
                mock_stdio_server.assert_called_once()

                # Verify app.run was called with streams and init options
                mock_run.assert_called_once()
                call_args = mock_run.call_args[0]
                assert len(call_args) == 3  # read_stream, write_stream, init_options


class TestMCPServerParameterValidation:
    """Test parameter validation for MCP server tools."""

    @pytest.mark.asyncio
    async def test_ingest_repository_missing_source(self):
        """Test that missing source parameter is handled."""
        # This should raise a KeyError which gets caught by call_tool
        result = await call_tool("ingest_repository", {})

        assert isinstance(result, list)
        assert len(result) == 1
        assert "Error ingesting repository" in result[0].text

    @pytest.mark.asyncio
    async def test_ingest_repository_invalid_parameters(self):
        """Test handling of invalid parameter types."""
        with patch("gitingest.mcp_server.ingest_async") as mock_ingest:
            # ingest_async should handle type validation, but let's test edge cases
            mock_ingest.side_effect = TypeError("Invalid parameter type")

            result = await call_tool(
                "ingest_repository",
                {
                    "source": "test",
                    "max_file_size": "not_an_integer",  # Invalid type
                },
            )

            assert isinstance(result, list)
            assert len(result) == 1
            assert "Error ingesting repository: Invalid parameter type" in result[0].text

    @pytest.mark.asyncio
    async def test_ingest_repository_empty_patterns(self):
        """Test handling of empty pattern lists."""
        with patch("gitingest.mcp_server.ingest_async") as mock_ingest:
            mock_ingest.return_value = ("summary", "tree", "content")

            args = {
                "source": "test",
                "include_patterns": [],
                "exclude_patterns": [],
            }

            await _handle_ingest_repository(args)

            call_args = mock_ingest.call_args[1]
            # Empty lists are treated as falsy and become None
            assert call_args["include_patterns"] is None
            assert call_args["exclude_patterns"] is None


class TestMCPServerEdgeCases:
    """Test edge cases and error scenarios."""

    @pytest.mark.asyncio
    async def test_call_tool_empty_arguments(self):
        """Test call_tool with empty arguments dict."""
        result = await call_tool("ingest_repository", {})

        assert isinstance(result, list)
        assert len(result) == 1
        assert "Error ingesting repository" in result[0].text

    @pytest.mark.asyncio
    async def test_handle_ingest_repository_partial_results(self):
        """Test handling when ingest_async returns partial results."""
        with patch("gitingest.mcp_server.ingest_async") as mock_ingest:
            # Test with empty strings
            mock_ingest.return_value = ("", "", "")

            result = await _handle_ingest_repository({"source": "test"})

            assert isinstance(result, list)
            assert len(result) == 1
            content = result[0].text
            assert "Repository Analysis: test" in content
            assert "## Summary" in content
            assert "## File Structure" in content
            assert "## Content" in content

    @pytest.mark.asyncio
    async def test_concurrent_tool_calls(self):
        """Test that concurrent tool calls work correctly."""
        with patch("gitingest.mcp_server.ingest_async") as mock_ingest:
            mock_ingest.return_value = ("summary", "tree", "content")

            # Create multiple concurrent calls
            tasks = [call_tool("ingest_repository", {"source": f"test-{i}"}) for i in range(3)]

            results = await asyncio.gather(*tasks)

            assert len(results) == 3
            for result in results:
                assert isinstance(result, list)
                assert len(result) == 1
                assert "Repository Analysis" in result[0].text
